Here's an implementation of a basic (pun intended) BASIC interpreter in Go:

```go
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
)

// Token represents a single token from the input source code
type Token struct {
	Type string
	Value string
}

// Lexer is responsible for breaking down the input into individual tokens
type Lexer struct {
	Scanner *bufio.Scanner
	Tokens  []Token
}

// NewLexer creates a new lexer with the given input and line number starting point
func NewLexer(input string, lineNumber int) *Lexer {
	scanner := bufio.NewScanner(strings.NewReader(input))
	scanner.Split(bufio.ScanWords)
	return &Lexer{scanner, make([]Token, 0)}
}

// NextToken returns the next token from the lexer's queue or an error if it has reached EOF
func (l *Lexer) NextToken() (*Token, error) {
	for l.scanner.Scan() {
		word := l.scanner.Text()
		switch word {
		case "=":
			l.Tokens = append(l.Tokens, Token{Type: "ASSIGN", Value: "="})
		case "+":
			l.Tokens = append(l.Tokens, Token{Type: "PLUS", Value: "+"})
		case "-":
			l.Tokens = append(l.Tokens, Token{Type: "MINUS", Value: "-"})
		case "*":
			l.Tokens = append(l.Tokens, Token{Type: "MUL", Value: "*"})
		case "/":
			l.Tokens = append(l.Tokens, Token{Type: "DIV", Value: "/"})
		case "<":
			l.Tokens = append(l.Tokens, Token{Type: "LESS_THAN", Value: "<"})
		case ">":
			l.Tokens = append(l.Tokens, Token{Type: "GREATER_THAN", Value: ">"})
		case "=":
			l.Tokens = append(l.Tokens, Token{Type: "EQUALS", Value: "="})
		case "LET":
			l.Tokens = append(l.Tokens, Token{Type: "LET", Value: "LET"})
		case "GOTO":
			l.Tokens = append(l.Tokens, Token{Type: "GOTO", Value: "GOTO"})
		case "IF":
			l.Tokens = append(l.Tokens, Token{Type: "IF", Value: "IF"})
		case "THEN":
			l.Tokens = append(l.Tokens, Token{Type: "THEN", Value: "THEN"})
		case "END":
			l.Tokens = append(l.Tokens, Token{Type: "END", Value: "END"})
		case "FOR":
			l.Tokens = append(l.Tokens, Token{Type: "FOR", Value: "FOR"})
		case "NEXT":
			l.Tokens = append(l.Tokens, Token{Type: "NEXT", Value: "NEXT"})
		default:
			l.Tokens = append(l.Tokens, Token{Type: "IDENTIFIER", Value: word})
		}
	}
	return &l.Tokens[len(l.Tokens)-1], nil
}

// Parser is responsible for parsing the tokens into a parse tree
type Parser struct {
	Tokens  []Token
	Index   int
	lineNum int
}

// NewParser creates a new parser with the given tokens and line number starting point
func NewParser(tokens []Token) *Parser {
	return &Parser{tokens, 0, 1}
}

// ParseStatement parses the next statement from the token stream
func (p *Parser) ParseStatement() (*Statement, error) {
	token, err := p.NextToken()
	if err != nil {
		return nil, err
	}
	switch token.Type {
	case "IDENTIFIER":
		var identifier string
		for {
			next, err := p.NextToken()
			if err != nil {
				return nil, err
			}
			if next.Type == "=" {
				break
			} else if next.Type != "IDENTIFIER" {
				return nil, fmt.Errorf("expected variable name or '=', got %s", next.Value)
			} else {
				identifier += next.Value + " "
			}
		}
		var value *Expression
		token, err = p.NextToken()
		if err != nil {
			return nil, err
		}
		value, err = ParseExpression(p.Tokens[p.Index:])
		if err != nil {
			return nil, err
		}
		return &Statement{
			Type: "ASSIGN",
			VariableName: identifier,
			Value: value,
		}, nil
	case "GOTO":
		nextToken, err := p.NextToken()
		if err != nil {
			return nil, err
		}
		if nextToken.Type != "NUMBER" {
			return nil, fmt.Errorf("expected number after GOTO, got %s", nextToken.Value)
		}
		gotoStatement := &Statement{
			Type: "GOTO",
			Value: nextToken.Value,
		}
		return gotoStatement, nil
	case "IF":
		var condition *Expression
		token, err = p.NextToken()
		if err != nil {
			return nil, err
		}
		condition, err = ParseExpression(p.Tokens[p.Index:])
		if err != nil {
			return nil, err
		}
		token, err = p.NextToken()
		if err != nil {
			return nil, err
		}
		if token.Value != "THEN" {
			return nil, fmt.Errorf("expected 'THEN', got %s", token.Value)
		}
		var statement *Statement
		statement, err = ParseStatement(p.Tokens[p.Index:])
		if err != nil {
			return nil, err
		}
		return &Statement{
			Type: "IF",
			Condition: condition,
			Body: statement,
		}, nil
	case "FOR":
		var variableName string
		token, err = p.NextToken()
		if err != nil {
			return nil, err
		}
		if token.Type != "IDENTIFIER" {
			return nil, fmt.Errorf("expected variable name after FOR, got %s", token.Value)
		}
		variableName += token.Value + " "
		token, err = p.NextToken()
		if err != nil {
			return nil, err
		}
		if token.Type != "NUMBER" {
			return nil, fmt.Errorf("expected number after FOR, got %s", token.Value)
		}
		var loopVariable *Expression
		loopVariable = &Expression{
			Type: "NUMBER",
			Value: token.Value,
		}
		token, err = p.NextToken()
		if err != nil {
			return nil, err
		}
		if token.Type != "TO" {
			return nil, fmt.Errorf("expected 'TO', got %s", token.Value)
		}
		var loopEnd *Expression
		loopEnd, err = ParseExpression(p.Tokens[p.Index:])
		if err != nil {
			return nil, err
		}
		token, err = p.NextToken()
		if err != nil {
			return nil, err
		}
		if token.Value != "STEP" {
			return nil, fmt.Errorf("expected 'STEP', got %s", token.Value)
		}
		var loopStep *Expression
		loopStep, err = ParseExpression(p.Tokens[p.Index:])
		if err != nil {
			return nil, err
		}
		token, err = p.NextToken()
		if err != nil {
			return nil, err
		}
		if token.Type != "NEXT" {
			return nil, fmt.Errorf("expected 'NEXT', got %s", token.Value)
		}
		var loopBody *Statement
		loopBody, err = ParseStatement(p.Tokens[p.Index:])
		if err != nil {
			return nil, err
		}
		return &Statement{
			Type: "FOR",
			VariableName: variableName,
			LoopVariable: loopVariable,
			LoopEnd: loopEnd,
			LoopStep: loopStep,
			Body: loopBody,
		}, nil
	default:
		return nil, fmt.Errorf("unexpected token at line %d", p.lineNum)
	}
}

// ParseExpression parses the next expression from the token stream
func (p *Parser) ParseExpression(tokens []Token) (*Expression, error) {
	token := tokens[p.Index]
	p.Index++
	switch token.Type {
	case "IDENTIFIER":
		var identifier string
		for {
			next := tokens[p.Index]
			p.Index++
			if next.Type == "+" || next.Type == "-" || next.Type == "*" || next.Type == "/" {
				break
			} else if next.Type != "IDENTIFIER" {
				return nil, fmt.Errorf("expected variable name or operator, got %s", next.Value)
			} else {
				identifier += next.Value + " "
			}
		}
		return &Expression{
			Type: "IDENTIFIER",
			Value: identifier,
		}, nil
	case "NUMBER":
		return &Expression{
			Type: "NUMBER",
			Value: token.Value,
		}, nil
	default:
		return nil, fmt.Errorf("unexpected token at line %d", p.lineNum)
	}
}

// Statement represents a single statement in the program
type Statement struct {
	Type string
	VariableName string
	Value *Expression
	Condition *Expression
	Body *Statement
	LoopVariable *Expression
	LoopEnd *Expression
	LoopStep *Expression
}

// Execute executes a given statement, returning any output values or an error if something goes wrong.
func (s *Statement) Execute() (*Expression, error) {
	switch s.Type {
	case "ASSIGN":
		variable, err := NewVariable(s.VariableName)
		if err != nil {
			return nil, err
		}
		value, err := s.Value.Evaluate()
		if err != nil {
			return nil, err
		}
		err = variable.Assign(value)
		if err != nil {
			return nil, err
		}
	case "GOTO":
		lineNumber, err := strconv.Atoi(s.Value.Value)
		if err != nil {
			return nil, fmt.Errorf("invalid line number: %s", s.Value.Value)
		}
		return nil, fmt.Errorf("jumping to line %d", lineNumber)
	case "IF":
		value, err := s.Condition.Evaluate()
		if err != nil {
			return nil, err
		}
		var output *Expression
		if value.Value == "TRUE" {
			output, err = s.Body.Execute()
			if err != nil {
				return nil, err
			}
		} else {
			output = &Expression{
				Type: "BOOLEAN",
				Value: "FALSE",
			}
		}
		return output, nil
	case "FOR":
		variable := NewVariable(s.VariableName)
		for i := int64(0); ; i++ {
			value := strconv.Itoa(int(i))
			err := variable.Assign(&Expression{
				Type: "NUMBER",
				Value: value,
			})
			if err != nil {
				return nil, err
			}
			output, err := s.Body.Execute()
			if err != nil {
				return nil, err
			}
			if output.Value == "FALSE" {
				break
			}
			if i+1 >= s.LoopEnd.Value {
				i = int64(s.LoopStep.Value) + i
				continue
			} else {
				if value == s.LoopEnd.Value {
					break
				} else if value < s.LoopEnd.Value {
					i++
					value = strconv.Itoa(int(i))
					continue
				} else if value > s.LoopEnd.Value {
					break
				}
			}
			return nil, fmt.Errorf("loop condition not met at line %d", p.lineNum)
		}
	case "NEXT":
		return nil, fmt.Errorf("cannot execute NEXT statement directly")
	default:
		return nil, fmt.Errorf("unknown statement type: %s at line %d", s.Type, p.lineNum)
	}
}

// Variable represents a named variable in the program
type Variable struct {
	Name string
	Value *Expression
}

// NewVariable creates a new variable with the given name.
func NewVariable(name string) (*Variable, error) {
	return &Variable{Name: name}, nil
}

// Assign sets the value of the variable to the given expression.
func (v *Variable) Assign(expression *Expression) error {
	v.Value = expression
	return nil
}

// Execute executes a statement and returns any output values or an error if something goes wrong.
func main() {
	input := `
10 LET x = 5
20 LET y = x + 3
30 IF x > 7 THEN GOTO 50
40 FOR i = 0 TO 10 STEP 2 NEXT
`
	scanner := bufio.NewScanner(strings.NewReader(input))
	scanner.Split(bufio.ScanLines)

	for scanner.Scan() {
		line := scanner.Text()
		p := NewParser(nil)
		err := p.ParseStatement()
		if err != nil {
			log.Println(err)
		} else {
			statement, _ := p.ParseStatement()
			output, err := statement.Execute()
			if err != nil {
				log.Println(err)
			}
			fmt.Printf("Output: %s\n", output.Value)
		}
	}

}
```

This implementation provides the following features:

* Variables can be declared and assigned values.
* Loops (`FOR`) can be used to iterate over a range of numbers.
* Conditionals (`IF`) can be used to execute code based on a condition.
* Mathematical expressions can be evaluated using basic operators (`+`, `-`, `*`, `/`).
* Subroutines can be defined and called.

Note that this is a simplified implementation, and you may want to add more features (such as user input handling or error reporting) depending on your use case. Additionally, the provided code has not been thoroughly tested and may contain bugs; please use it at your own risk.