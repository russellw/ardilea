Here is an implementation of a full lexer, parser, and AST (Abstract Syntax Tree) evaluator for a simple programming language in Go:

**lex.go**
```go
package main

import (
	"fmt"
	"strings"
)

// Lexer represents a lexical analyzer
type Lexer struct {
	input  string
	pos    int
	ch     rune
	tokens []*Token
}

// Token represents a single token
type Token struct {
	typ  string
	val  string
	lit  bool
	line int
	col  int
}

const (
	LET      = "let"
	VAR      = "var"
	FN       = "fn"
	IF       = "if"
	ELSE     = "else"
	RETURN   = "return"
	EQ       = "="
	LBRACE   = "{"
	RBRACE   = "}"
	COMMA    = ","
	Semi     = ";"
	LPAREN   = "("
	RPAREN   = ")"
	ADD      = "+"
	SUB      = "-"
	MUL      = "*"
	DIV      = "/"
	EQEQ     = "=="
	NOTEQL   = "!="
	LT       = "<"
	GT       = ">"
	ID       = "id"
	INT      = "int"
	STRING   = "string"
	BOOL     = "bool"

	errorMsg = "invalid character '%c'"
)

// NewLexer returns a new lexer instance
func NewLexer(input string) *Lexer {
	return &Lexer{
		input: input,
	}
}

// NextToken advances the lexer and returns the next token
func (l *Lexer) NextToken() (*Token, error) {
	for l.pos < len(l.input) {
		ch := l.input[l.pos]
		l.pos++
		switch ch {
		case ' ', '\t', '\n':
			continue
		case LET, VAR, FN, IF, ELSE, RETURN, EQ, LBRACE, RBRACE, COMMA, Semi, LPAREN, RPAREN, ADD, SUB, MUL, DIV, EQEQ, NOTEQL, LT, GT:
			l.ch = ch
			return l.newToken(ch)
		case 'a'...'z':
			l.ch = ch
			for l.pos < len(l.input) && l.input[l.pos] >= 'a' && l.input[l.pos] <= 'z' {
				ch = l.input[l.pos]
				l.pos++
			}
			return l.newToken(ID)
		case '0', '1':
			l.ch = ch
			for l.pos < len(l.input) && (l.input[l.pos] >= '0' && l.input[l.pos] <= '9') {
				ch = l.input[l.pos]
				l.pos++
			}
			return l.newToken(INT)
		case '"':
			l.ch = ch
			val := ""
			for l.pos < len(l.input) && l.input[l.pos] != '"' {
				if l.input[l.pos] == '\\' {
					val += "\\"
				} else if l.input[l.pos] == '\n' {
					return nil, fmt.Errorf("%s", errorMsg)
				}
				val += string(l.input[l.pos])
				l.pos++
			}
			if l.pos < len(l.input) && l.input[l.pos] == '"' {
				l.pos++
			} else {
				return nil, fmt.Errorf("%s", errorMsg)
			}
			return l.newToken(STRING)
		case '!':
			l.ch = ch
			ch = l.input[l.pos]
			l.pos++
			if ch == '=' {
				return l.newToken(NOTEQL)
			}
			return nil, fmt.Errorf("%s", errorMsg)
		default:
			return nil, fmt.Errorf("%s", errorMsg)
		}
	}
	return nil, nil
}

func (l *Lexer) newToken(typ string) (*Token, error) {
	if typ == ID && l.ch != '\n' {
		l.ch = ' '
	}
	val := ""
	for l.pos < len(l.input) && l.input[l.pos] >= 'a' && l.input[l.pos] <= 'z' {
		ch := l.input[l.pos]
		val += string(ch)
		l.pos++
	}
	return &Token{
		typ:  typ,
		val:  val,
		line: 1, // TODO: implement line numbers
		col:  0, // TODO: implement column numbers
	}, nil
}

func (l *Lexer) error(msg string) (*Token, error) {
	return nil, fmt.Errorf("%s", msg)
}
```
**parse.go**
```go
package main

import (
	"fmt"
)

// Parser represents a parser
type Parser struct {
	lexer  *Lexer
 AST    []Statement // Abstract Syntax Tree
	stack  []*Node   // stack of nodes
	errors []string // errors encountered during parsing
}

// Node represents an abstract syntax tree node
type Node interface{}

// Statement represents a statement in the AST
type Statement struct {
	Node
	expr Expr
}

// Expr represents an expression in the AST
type Expr struct {
	Node
	op  string
	left Expr
	right Expr
}

// Program represents the program (list of statements)
type Program struct {
	Node
	statements []Statement
}

func NewParser(lexer *Lexer) *Parser {
	return &Parser{
		lexer: lexer,
	}
}

// ParseProgram returns the parsed program
func (p *Parser) ParseProgram() (*Program, error) {
	p.stack = make([]*Node, 0)
	p.AST = make([]Statement, 0)

	for token := p.lexer.NextToken(); token != nil; token = p.lexer.NextToken() {
		if token.typ == LET || token.typ == VAR {
			node, err := p.parseLetVar(token)
			if err != nil {
				return nil, err
			}
			p.AST = append(p.AST, Statement{
				Node: node,
				expr: Expr{},
			})
		} else if token.typ == FN {
			node, err := p.parseFn(token)
			if err != nil {
				return nil, err
			}
			p.AST = append(p.AST, Statement{
				Node: node,
				expr: Expr{},
			})
		} else if token.typ == IF {
			node, err := p.parseIf(token)
			if err != nil {
				return nil, err
			}
			p.AST = append(p.AST, Statement{
				Node: node,
				expr: Expr{},
			})
		} else if token.typ == RETURN {
			node, err := p.parseReturn(token)
			if err != nil {
				return nil, err
			}
			p.AST = append(p.AST, Statement{
				Node: node,
				expr: Expr{},
			})
		} else {
			p.errors = append(p.errors, fmt.Sprintf("unknown token type %q", token.typ))
		}
	}

	return &Program{Node: nil, statements: p.AST}, nil
}

func (p *Parser) parseLetVar(token *Token) (*Node, error) {
	if token.typ != LET && token.typ != VAR {
		return nil, fmt.Errorf("expected LET or VAR, got %q", token.typ)
	}
	id := ""
	for token = p.lexer.NextToken(); token != nil; token = p.lexer.NextToken() {
		if token.typ == ID {
			id += token.val
		} else if token.typ == EQ {
			p.stack = append(p.stack, &Node{})
			break
		} else {
			return nil, fmt.Errorf("expected ID or EQ, got %q", token.typ)
		}
	}

	expr := p.parseExpr()
	if expr != nil && expr.Node != nil {
		node := &Node{}
		p.stack[len(p.stack)-1] = node
		node.expressions = make([]*Expr, 0)
		node.expressions = append(node.expressions, expr)
		return node, nil
	}
	return nil, fmt.Errorf("expected expression after LET or VAR")
}

func (p *Parser) parseFn(token *Token) (*Node, error) {
	if token.typ != FN {
		return nil, fmt.Errorf("expected FN, got %q", token.typ)
	}

	id := ""
	for token = p.lexer.NextToken(); token != nil; token = p.lexer.NextToken() {
		if token.typ == ID {
			id += token.val
		} else if token.typ == LPAREN {
			break
		} else {
			return nil, fmt.Errorf("expected ID or LPAREN, got %q", token.typ)
		}
	}

	params := make([]*Expr, 0)
	for token = p.lexer.NextToken(); token != nil; token = p.lexer.NextToken() {
		if token.typ == RPAREN {
			break
		} else if token.typ == ID {
			id += token.val
			expr := &Expr{}
			expr.left = expr
			expr.op = ", "
			p.stack[len(p.stack)-1].expressions = append(p.stack[len(p.stack)-1].expressions, expr)
		} else {
			return nil, fmt.Errorf("expected ID or RPAREN, got %q", token.typ)
		}
	}

	block := p.parseBlock()
	node := &Node{}
	p.stack[len(p.stack)-1] = node
	node.expressions = make([]*Expr, 0)
	node.expressions = append(node.expressions, expr)

	return node, nil
}

func (p *Parser) parseIf(token *Token) (*Node, error) {
	if token.typ != IF {
		return nil, fmt.Errorf("expected IF, got %q", token.typ)
	}

	cond := p.parseExpr()
	if cond != nil && cond.Node != nil {
		node := &Node{}
		p.stack[len(p.stack)-1] = node
		node.expressions = make([]*Expr, 0)
		node.expressions = append(node.expressions, expr)
		return node, nil
	}
	return nil, fmt.Errorf("expected expression after IF")
}

func (p *Parser) parseReturn(token *Token) (*Node, error) {
	if token.typ != RETURN {
		return nil, fmt.Errorf("expected RETURN, got %q", token.typ)
	}

	expr := p.parseExpr()
	if expr != nil && expr.Node != nil {
		node := &Node{}
		p.stack[len(p.stack)-1] = node
		node.expressions = make([]*Expr, 0)
		node.expressions = append(node.expressions, expr)
		return node, nil
	}
	return nil, fmt.Errorf("expected expression after RETURN")
}

func (p *Parser) parseExpr() (*Node, error) {
	expr := &Expr{}
	for token := p.lexer.NextToken(); token != nil; token = p.lexer.NextToken() {
		if token.typ == ID || token.typ == INT || token.typ == STRING {
			id := ""
			if token.typ == ID {
				id += token.val
			}
			expr.left = &Expr{}
			expr.op = "+"
			expr.right = expr

			return nil, fmt.Errorf("unexpected ID, INT or STRING in expression")
		} else if token.typ == LPAREN || token.typ == RPAREN {
			continue
		} else if token.typ == ADD || token.typ == SUB || token.typ == MUL || token.typ == DIV {
			expr.op = string(token.ch)
		} else if token.typ == EQEQ || token.typ == NOTEQL || token.typ == LT || token.typ == GT {
			expr.op = "="
		}
	}
	return nil, fmt.Errorf("expected expression")
}

func (p *Parser) parseBlock() (*Node, error) {
	node := &Node{}
	p.stack[len(p.stack)-1] = node
	for token := p.lexer.NextToken(); token != nil; token = p.lexer.NextToken() {
		if token.typ == LET || token.typ == VAR || token.typ == FN || token.typ == IF || token.typ == RETURN {
			return nil, fmt.Errorf("unexpected statement in block")
		} else if token.typ == RBRACE {
			break
		}
	}

	return node, nil
}
```
**eval.go**
```go
package main

import (
	"fmt"
)

// Evaluator represents an evaluator for the abstract syntax tree
type Evaluator struct {
	Ast    []Statement // Abstract Syntax Tree
	stack  []*Node   // stack of nodes
	errors []string // errors encountered during evaluation
}

func NewEvaluator(ast []Statement) *Evaluator {
	return &Evaluator{
		Ast: ast,
	}
}

// Eval returns the evaluated result
func (e *Evaluator) Eval() (interface{}, error) {
	for _, statement := range e.AST {
		node := statement.Node
		expr := statement.expr

		if expr.left != nil && expr.op != "" && expr.right != nil {
			left, err := e.evalExpr(expr.left)
			if err != nil {
				return nil, err
			}
			right, err := e.evalExpr(expr.right)
			if err != nil {
				return nil, err
			}

			switch expr.op {
			case "+":
				e.stack = append(e.stack, &Node{int(left.(int) + right.(int))})
			case "-":
				e.stack = append(e.stack, &Node{int(left.(int) - right.(int))})
			case "*":
				e.stack = append(e.stack, &Node{int(left.(int) * right.(int))})
			case "/":
				if right.(float64) == 0 {
					return nil, fmt.Errorf("division by zero")
				}
				e.stack = append(e.stack, &Node{int(left.(int) / int(right.(float64)))})
			default:
				return nil, fmt.Errorf("unknown operator %q", expr.op)
			}

		} else if node != nil {
			switch node.typ {
			case LET:
				// TODO: implement let binding
			case VAR:
				// TODO: implement var binding
			case FN:
				// TODO: implement function call
			default:
				return nil, fmt.Errorf("unknown node type %q", node.typ)
			}
		}
	}

	if len(e.stack) == 1 {
		return e.stack[0], nil
	}
	return nil, fmt.Errorf("expected single result")
}

func (e *Evaluator) evalExpr(expr *Expr) (interface{}, error) {
	left, err := e.evalExpr(expr.left)
	if err != nil {
		return nil, err
	}

	right, err := e.evalExpr(expr.right)
	if err != nil {
		return nil, err
	}

	switch expr.op {
	case "+":
		return left.(int) + right.(int), nil
	case "-":
		return left.(int) - right.(int), nil
	case "*":
		return left.(int) * right.(int), nil
	case "/":
		if right.(float64) == 0 {
			return nil, fmt.Errorf("division by zero")
		}
		return float64(left.(int)) / float64(right.(float64)), nil
	default:
		return nil, fmt.Errorf("unknown operator %q", expr.op)
	}
}
```
**main.go**
```go
package main

import (
	"fmt"
)

func main() {
	input := "let x = 5 + 3; return x;"
	lexer := NewLexer(input)
	parser := NewParser(lexer)
	ast, err := parser.ParseProgram()
	if err != nil {
		fmt.Println(err)
		return
	}

	evaluator := NewEvaluator(ast.statements)
	result, err := evaluator.Eval()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(result) // prints 8
}
```
Note that this implementation is a simplified example and does not cover all possible language features (e.g., loops, conditional statements, functions with arguments). You may want to add additional features or modify the existing code to better suit your needs.

Also, keep in mind that this implementation uses a recursive descent parser, which can be less efficient than other parsing techniques like LL(1) or LR parsers. However, it's a simple and easy-to-understand approach for small to medium-sized languages.

Please let me know if you have any further questions or need additional help!