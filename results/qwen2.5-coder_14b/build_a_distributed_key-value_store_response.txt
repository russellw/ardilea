Building a distributed key-value store in Go with features such as consistent hashing, replication, and fault tolerance is a complex task that involves several components. Below is an outline of how you might design and implement such a system. This will include a high-level overview of the architecture, the implementation of each component, and a simple client library and REST API.

### Architecture Overview

1. **Nodes**: Each node in the cluster stores a subset of the key-value pairs.
2. **Ring of Nodes**: A consistent hash ring is used to map keys to nodes efficiently.
3. **Replication**: Each key-value pair is replicated across multiple nodes for fault tolerance.
4. **Client Library**: Provides methods for interacting with the key-value store.
5. **REST API**: Exposes HTTP endpoints for client applications.

### Components

#### 1. Consistent Hashing Ring

Consistent hashing helps in efficiently distributing keys across nodes and allows for scalable addition or removal of nodes without causing significant rehashing.

```go
package hashring

import (
	"sort"
)

type Node struct {
	ID string
}

type HashRing struct {
	nodes  []Node
	ring   map[uint32]*Node
	hasher func([]byte) uint32
}

func NewHashRing(hasher func([]byte) uint32) *HashRing {
	return &HashRing{
		hasher: hasher,
		ring:   make(map[uint32]*Node),
	}
}

func (hr *HashRing) AddNode(node Node, replicas int) {
	for i := 0; i < replicas; i++ {
		key := hash(hr.hasher([]byte(node.ID + ":" + string(i))))
		hr.ring[key] = &node
	}
	hr.nodes = append(hr.nodes, node)
	sort.Slice(hr.nodes, func(i, j int) bool {
		return hr.hasher([]byte(hr.nodes[i].ID)) < hr.hasher([]byte(hr.nodes[j].ID))
	})
}

func (hr *HashRing) GetNode(key string) *Node {
	if len(hr.ring) == 0 {
		return nil
	}
	hash := hash(hr.hasher([]byte(key)))
	for _, node := range hr.nodes {
		nodeKey := hash(hr.hasher([]byte(node.ID + ":0")))
		if hash <= nodeKey {
			return &node
		}
	}
	return &hr.nodes[0]
}

func hash(n uint32) uint32 {
	const prime = 16777213
	return (n * prime) % (1 << 32)
}
```

#### 2. Node Implementation

Each node will handle the storage of key-value pairs and provide methods for getting, setting, and deleting them.

```go
package node

import (
	"sync"
)

type KeyValueStore struct {
	store map[string]string
	mu    sync.RWMutex
}

func NewKeyValueStore() *KeyValueStore {
	return &KeyValueStore{
		store: make(map[string]string),
	}
}

func (kvs *KeyValueStore) Get(key string) (string, bool) {
	kvs.mu.RLock()
	defer kvs.mu.RUnlock()
	val, ok := kvs.store[key]
	return val, ok
}

func (kvs *KeyValueStore) Set(key, value string) {
	kvs.mu.Lock()
	defer kvs.mu.Unlock()
	kvs.store[key] = value
}

func (kvs *KeyValueStore) Delete(key string) {
	kvs.mu.Lock()
	defer kvs.mu.Unlock()
	delete(kvs.store, key)
}
```

#### 3. Client Library

The client library will provide a simple API for interacting with the key-value store.

```go
package client

import (
	"bytes"
	"encoding/json"
	"net/http"
)

type Client struct {
	address string
}

func NewClient(address string) *Client {
	return &Client{address: address}
}

func (c *Client) Get(key string) (string, error) {
	resp, err := http.Get(c.address + "/get?key=" + key)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var response struct {
		Value string `json:"value"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return "", err
	}

	return response.Value, nil
}

func (c *Client) Set(key, value string) error {
	payload, _ := json.Marshal(map[string]string{"key": key, "value": value})
	resp, err := http.Post(c.address+"/set", "application/json", bytes.NewBuffer(payload))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

func (c *Client) Delete(key string) error {
	resp, err := http.NewRequest("DELETE", c.address+"/delete?key="+key, nil)
	if err != nil {
		return err
	}
	resp, err = http.DefaultClient.Do(resp)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}
```

#### 4. REST API

The REST API will expose endpoints for GET, SET, and DELETE operations.

```go
package main

import (
	"encoding/json"
	"net/http"

	"github.com/yourusername/keyvaluestore/client"
)

func main() {
	http.HandleFunc("/get", func(w http.ResponseWriter, r *http.Request) {
		key := r.URL.Query().Get("key")
		value, err := client.Get(key)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"value": value})
	})

	http.HandleFunc("/set", func(w http.ResponseWriter, r *http.Request) {
		var payload map[string]string
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		if err := client.Set(payload["key"], payload["value"]); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusOK)
	})

	http.HandleFunc("/delete", func(w http.ResponseWriter, r *http.Request) {
		key := r.URL.Query().Get("key")
		if err := client.Delete(key); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusOK)
	})

	http.ListenAndServe(":8080", nil)
}
```

### Conclusion

This is a simplified version of a distributed key-value store. In a real-world scenario, you would need to add more features such as:

- **Replication**: Implement logic to replicate data across multiple nodes.
- **Fault Tolerance**: Handle node failures and automatic recovery.
- **Load Balancing**: Distribute requests evenly across the cluster.
- **Security**: Add authentication and encryption for secure communication.
- **Scalability**: Ensure the system can handle large volumes of data and high traffic.

Implementing a distributed system is challenging, but Go's concurrency model and standard library make it a good choice for building such systems.