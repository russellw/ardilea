Creating a sophisticated caching system in Go involves several components: managing time-to-live (TTL) for cache entries, implementing least-recently-used (LRU) eviction policy, ensuring data persistence across restarts, and enabling distributed cache invalidation. Below is a high-level design and implementation guide to achieve this.

### 1. Define the Cache Entry

First, define a structure for the cache entry that includes the value, TTL, and last accessed time.

```go
package main

import (
    "container/list"
    "time"
)

type cacheEntry struct {
    key        string
    value      interface{}
    expiresAt  time.Time
    accessedAt time.Time
}
```

### 2. Implement LRU Cache with TTL

Use a combination of `container/list` for LRU eviction and a map to track entries.

```go
type LRUCache struct {
    capacity int
    cacheMap map[string]*list.Element
    list     *list.List
}

func NewLRUCache(capacity int) *LRUCache {
    return &LRUCache{
        capacity: capacity,
        cacheMap: make(map[string]*list.Element),
        list:     list.New(),
    }
}

func (c *LRUCache) Add(key string, value interface{}, ttl time.Duration) {
    expiresAt := time.Now().Add(ttl)
    entry := &cacheEntry{key, value, expiresAt, time.Now()}
    element := c.list.PushFront(entry)
    c.cacheMap[key] = element

    if len(c.cacheMap) > c.capacity {
        oldest := c.list.Back()
        if oldest != nil {
            e := c.list.Remove(oldest).(*cacheEntry)
            delete(c.cacheMap, e.key)
        }
    }
}

func (c *LRUCache) Get(key string) interface{} {
    element, found := c.cacheMap[key]
    if !found {
        return nil
    }
    entry := element.Value.(*cacheEntry)
    if time.Now().After(entry.expiresAt) {
        c.list.Remove(element)
        delete(c.cacheMap, key)
        return nil
    }
    entry.accessedAt = time.Now()
    c.list.MoveToFront(element)
    return entry.value
}

func (c *LRUCache) Remove(key string) {
    element, found := c.cacheMap[key]
    if found {
        c.list.Remove(element)
        delete(c.cacheMap, key)
    }
}
```

### 3. Persistence

To ensure persistence across restarts, you can serialize the cache to a file or use a database.

```go
import (
    "encoding/json"
    "os"
)

func (c *LRUCache) Save(filePath string) error {
    var entries []cacheEntry
    for _, element := range c.cacheMap {
        entry := element.Value.(*cacheEntry)
        if time.Now().Before(entry.expiresAt) {
            entries = append(entries, *entry)
        }
    }
    data, err := json.Marshal(entries)
    if err != nil {
        return err
    }
    return os.WriteFile(filePath, data, 0644)
}

func (c *LRUCache) Load(filePath string) error {
    var entries []cacheEntry
    data, err := os.ReadFile(filePath)
    if err != nil {
        return err
    }
    err = json.Unmarshal(data, &entries)
    if err != nil {
        return err
    }
    for _, entry := range entries {
        c.Add(entry.key, entry.value, time.Until(entry.expiresAt))
    }
    return nil
}
```

### 4. Distributed Cache Invalidation

For distributed cache invalidation, you can use a message queue like RabbitMQ or Redis Pub/Sub.

```go
import (
    "github.com/go-redis/redis/v8"
)

type CacheInvalidator struct {
    client *redis.Client
}

func NewCacheInvalidator(client *redis.Client) *CacheInvalidator {
    return &CacheInvalidator{client: client}
}

func (ci *CacheInvalidator) InvalidateKey(key string) error {
    return ci.client.Publish(context.Background(), "cache_invalidation", key).Err()
}

func (ci *CacheInvalidator) SubscribeToInvalidations() (<-chan *redis.Message, error) {
    pubsub := ci.client.Subscribe(context.Background(), "cache_invalidation")
    ch := pubsub.Channel()
    return ch, nil
}
```

### 5. Putting It All Together

Combine the above components into a single application.

```go
func main() {
    cache := NewLRUCache(100)
    // Load from persistent storage if available
    _ = cache.Load("cache.json")

    invalidator := NewCacheInvalidator(redis.NewClient(&redis.Options{Addr: "localhost:6379"}))
    ch, _ := invalidator.SubscribeToInvalidations()

    go func() {
        for msg := range ch {
            key := msg.Payload
            if entry, found := cache.cacheMap[key]; found {
                cache.list.Remove(entry)
                delete(cache.cacheMap, key)
            }
        }
    }()

    // Example usage
    cache.Add("key1", "value1", 5*time.Minute)
    value := cache.Get("key1")
    fmt.Println(value)

    // Invalidate a key
    _ = invalidator.InvalidateKey("key1")

    // Save to persistent storage before shutdown
    defer func() {
        _ = cache.Save("cache.json")
    }()
}
```

### Conclusion

This implementation provides a basic framework for a sophisticated caching system in Go, including TTL management, LRU eviction, persistence, and distributed invalidation. Depending on your specific requirements, you may need to extend or modify this implementation.