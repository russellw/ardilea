Creating a complete compiler is an extensive task that involves multiple components such as lexical analysis, syntax parsing, semantic analysis, code generation, and optimization. Below is a high-level description of how you might structure such a project for a subset of C targeting x86-64 assembly. This example will not provide full implementations but will outline the key steps and considerations.

### 1. Lexical Analysis
The lexical analyzer (lexer) scans the source code and converts it into a sequence of tokens. Tokens are the smallest units that have meaning in the language, such as keywords, identifiers, operators, and literals.

- **Tools**: Flex or Bison for generating lexers.
- **Implementation**:
  - Define token types: `KEYWORD`, `IDENTIFIER`, `OPERATOR`, `LITERAL`.
  - Write a lexer specification file (e.g., `lexer.l`) that maps regular expressions to tokens.

### 2. Syntax Parsing
The syntax parser takes the stream of tokens from the lexer and constructs an Abstract Syntax Tree (AST) based on the grammar of C.

- **Tools**: Bison for generating parsers.
- **Implementation**:
  - Define a context-free grammar for your subset of C.
  - Write a grammar specification file (e.g., `parser.y`) that defines rules for constructing the AST.

### 3. Semantic Analysis
Semantic analysis involves checking the meaning of the program, ensuring type correctness and other semantic rules are followed.

- **Implementation**:
  - Traverse the AST to resolve types, check for undeclared identifiers, handle scope issues.
  - Implement a symbol table to manage declarations and their scopes.

### 4. Code Generation
Generate x86-64 assembly code from the AST.

- **Implementation**:
  - Use a backend generator that translates each node in the AST into corresponding assembly instructions.
  - Manage registers, memory allocation, and function calls.

### 5. Optimization Passes
Optimize the generated assembly code to improve performance.

- **Types of Optimizations**: Constant folding, dead code elimination, register allocation, loop optimization.
- **Implementation**:
  - Implement simple optimizations as part of the backend generator or as separate passes after initial code generation.

### 6. Symbol Table Management
A symbol table is crucial for managing variables, functions, and types throughout the compilation process.

- **Implementation**:
  - Use a hash map or tree-based structure to store symbols with their attributes (type, scope, etc.).
  - Implement nested scopes to handle block-level declarations.

### Example Code Structure

```plaintext
compiler/
├── src/
│   ├── lexer.l      # Lexical analyzer specification
│   ├── parser.y     # Syntax parser specification
│   ├── ast.cpp      # Abstract Syntax Tree implementation
│   ├── semantic.cpp # Semantic analysis implementation
│   ├── codegen.cpp  # Code generation to x86-64 assembly
│   └── optimize.cpp # Optimization passes
├── include/
│   ├── lexer.h
│   ├── parser.h
│   ├── ast.h
│   ├── semantic.h
│   ├── codegen.h
│   └── optimize.h
├── Makefile       # Build system configuration
└── README.md      # Project description and usage instructions
```

### Building the Compiler

1. **Install Dependencies**: Ensure you have Flex, Bison, and a C++ compiler installed.
2. **Generate Lexer/Parser**: Use Flex and Bison to generate lexer and parser code from their respective specification files.
3. **Compile Source Code**: Compile all source files using your preferred build system (e.g., Makefile).
4. **Run the Compiler**: Execute the compiled binary with a C source file as input.

### Example Commands

```bash
# Generate lexer/parser code
flex -o lexer.cpp lexer.l
bison -d -o parser.cpp parser.y

# Compile the project
make

# Run the compiler
./compiler example.c
```

This high-level guide provides an overview of building a C compiler targeting x86-64 assembly. Each step involves detailed implementation, which requires a deep understanding of compilers and low-level programming concepts. For educational purposes, you might start with simpler projects that focus on specific components, such as a calculator or a small expression evaluator, before tackling the full language.