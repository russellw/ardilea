Creating a TCP/IP server in Go for a multi-user chat system involves several steps, including setting up the server to handle multiple clients, implementing user authentication, managing chat rooms, and persisting messages. Below is a simplified version of such a server. This example will use goroutines to handle multiple clients concurrently and a simple in-memory data structure for simplicity. For a production environment, you would want to use persistent storage like a database and possibly more sophisticated concurrency handling.

Here's a basic implementation:

```go
package main

import (
	"bufio"
	"fmt"
	"net"
	"os"
	"strings"
	"sync"
)

type Client struct {
	conn     net.Conn
	username string
	room     *Room
}

type Room struct {
	name    string
	mu      sync.Mutex
clients map[*Client]struct{}
	messages []string
}

var (
	serverRooms = make(map[string]*Room)
	roomsMu     sync.Mutex
)

func main() {
	listener, err := net.Listen("tcp", ":8080")
	if err != nil {
		fmt.Println("Error starting server:", err)
		os.Exit(1)
	}
	defer listener.Close()

	fmt.Println("Server started on :8080")

	for {
		conn, err := listener.Accept()
		if err != nil {
			fmt.Println("Error accepting connection:", err)
			continue
		}
		go handleConnection(conn)
	}
}

func handleConnection(conn net.Conn) {
	defer conn.Close()

	client := &Client{conn: conn}
	reader := bufio.NewReader(conn)

	for {
		message, err := reader.ReadString('\n')
		if err != nil {
			fmt.Println("Error reading from client:", err)
			return
		}

		command := strings.TrimSpace(message)
		switch {
		case strings.HasPrefix(command, "JOIN"):
			roomName := strings.SplitN(command, " ", 2)[1]
			client.JoinRoom(roomName)

		case strings.HasPrefix(command, "MSG "):
			msg := strings.TrimPrefix(command, "MSG ")
			client.SendMessage(msg)

		case command == "AUTH":
			username := strings.TrimSpace(reader.ReadString('\n'))
			client.Authenticate(username)

		default:
			fmt.Fprintf(conn, "Unknown command: %s\n", message)
		}
	}
}

func (c *Client) Authenticate(username string) {
	c.username = username
	fmt.Fprintf(c.conn, "Welcome, %s! You are now authenticated.\n", username)
}

func (c *Client) JoinRoom(roomName string) {
	roomsMu.Lock()
	room, exists := serverRooms[roomName]
	if !exists {
		room = &Room{name: roomName, clients: make(map[*Client]struct{})}
		serverRooms[roomName] = room
	}
	roomsMu.Unlock()

	c.room = room
	room.mu.Lock()
	room.clients[c] = struct{}{}
	for client := range room.clients {
		if client != c {
			fmt.Fprintf(client.conn, "%s joined the room.\n", c.username)
		}
	}
	room.mu.Unlock()

	fmt.Fprintf(c.conn, "You have joined %s\n", roomName)
}

func (c *Client) SendMessage(message string) {
	room := c.room
	if room == nil {
		fmt.Fprintln(c.conn, "You are not in any room.")
		return
	}

	room.mu.Lock()
	for client := range room.clients {
		fmt.Fprintf(client.conn, "%s: %s", c.username, message)
	}
	room.messages = append(room.messages, fmt.Sprintf("%s: %s", c.username, message))
	room.mu.Unlock()
}
```

### Key Features:
1. **User Authentication**: Clients can authenticate by sending an `AUTH` command followed by their username.
2. **Room Management**: Clients can join rooms using the `JOIN` command and leave them when they disconnect.
3. **Message Sending**: Once authenticated and in a room, clients can send messages to all other users in the same room using the `MSG` command.

### Notes:
- This implementation is very basic and lacks features like user management, message persistence, and secure communication.
- For production use, consider adding error handling, logging, and security measures such as TLS for encrypted communication.
- Message persistence could be implemented by writing messages to a file or database.
- User management might include password storage and verification.

This example provides a foundation that you can expand upon to create a more robust chat system.