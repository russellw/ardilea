Creating a complete database query engine in Go is a complex task that involves several components, including parsing SQL, optimizing queries, executing them against in-memory data structures with indexing, and handling concurrency safely. Below is a high-level overview of how you might design such an engine:

### 1. **Parsing SQL**

To parse SQL, you can use a library like `go-sql-parser`, which provides a parser for standard SQL.

```go
import (
    "github.com/ziutek/mymysql/mysql/godrv"
)

func ParseSQL(sql string) (parsedQuery *godrv.Query, err error) {
    // Use go-sql-parser to parse the SQL query
    parsedQuery, err = godrv.Parse(sql)
    if err != nil {
        return nil, err
    }
    return parsedQuery, nil
}
```

### 2. **Optimizing Queries**

Optimizing queries involves analyzing the parsed SQL and determining the best execution plan. This can be a complex process that depends on the structure of your data and the specific query being executed.

```go
func OptimizeQuery(parsedQuery *godrv.Query, schema map[string][]string) (optimizedPlan ExecutionPlan, err error) {
    // Implement optimization logic based on the parsed query and schema
    // This could involve selecting the best index, estimating row counts, etc.
    optimizedPlan = generateExecutionPlan(parsedQuery, schema)
    return optimizedPlan, nil
}
```

### 3. **Executing Queries**

To execute queries against in-memory data structures with indexing, you need to implement data storage and retrieval mechanisms.

```go
type InMemoryTable struct {
    Data     map[string][]interface{} // Columns -> Rows
    Indexes  map[string]string        // Column name -> Index type
}

func ExecuteQuery(optimizedPlan ExecutionPlan, tables map[string]*InMemoryTable) (results [][]interface{}, err error) {
    // Implement execution logic based on the optimized plan and data structures
    // This could involve scanning tables, joining tables, filtering rows, etc.
    results = scanTables(tables, optimizedPlan)
    return results, nil
}
```

### 4. **Concurrency Management**

Handling concurrency safely is crucial for a database engine. You can use Go's built-in synchronization primitives like `sync.Mutex` or channels to manage concurrent access.

```go
type Database struct {
    tables     map[string]*InMemoryTable
    schema     map[string][]string
    mu         sync.RWMutex
}

func (db *Database) ExecuteSQL(sql string) ([][]interface{}, error) {
    db.mu.Lock()
    defer db.mu.Unlock()

    parsedQuery, err := ParseSQL(sql)
    if err != nil {
        return nil, err
    }

    optimizedPlan, err := OptimizeQuery(parsedQuery, db.schema)
    if err != nil {
        return nil, err
    }

    results, err := ExecuteQuery(optimizedPlan, db.tables)
    if err != nil {
        return nil, err
    }

    return results, nil
}
```

### 5. **Indexing**

Implementing indexing can significantly speed up query execution by reducing the amount of data that needs to be scanned.

```go
func CreateIndex(table *InMemoryTable, columnName string) error {
    // Implement index creation logic based on the column name and table structure
    table.Indexes[columnName] = "hash" // Example: hash index
    return nil
}
```

### 6. **Error Handling**

Proper error handling is essential for a robust database engine. Ensure that all functions handle errors appropriately and provide meaningful error messages.

### 7. **Testing**

Thoroughly test your query engine with various SQL queries to ensure correctness and performance. Use Go's testing framework to write unit tests and integration tests.

```go
func TestExecuteSQL(t *testing.T) {
    db := &Database{
        tables: map[string]*InMemoryTable{
            "users": {
                Data: map[string][]interface{}{
                    "id":   {1, 2, 3},
                    "name": {"Alice", "Bob", "Charlie"},
                },
                Indexes: make(map[string]string),
            },
        },
        schema: map[string][]string{
            "users": {"id", "name"},
        },
    }

    results, err := db.ExecuteSQL("SELECT * FROM users WHERE id = 1")
    if err != nil {
        t.Fatalf("Failed to execute query: %v", err)
    }

    // Add assertions to check the results
}
```

### Conclusion

This is a simplified overview of how you might design a complete database query engine in Go. Each component, from parsing SQL to executing queries, involves complex logic and optimizations. In practice, building a full-featured database engine would require much more detailed implementation and consideration of many additional factors, such as transaction management, support for different data types, and more sophisticated query optimization techniques.