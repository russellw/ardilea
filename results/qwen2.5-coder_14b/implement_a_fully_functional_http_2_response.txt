Creating a fully functional HTTP/2 server from scratch is a complex task that involves understanding both the HTTP/2 protocol itself and the Go programming language. Below, I will outline a simplified version of an HTTP/2 server in Go that includes basic features such as connection handling, multiplexing, and flow control. This example will not cover all aspects of the HTTP/2 specification but will provide a foundation to build upon.

### Prerequisites

Before starting, ensure you have a good understanding of:

- The basics of HTTP/1.x
- The fundamentals of TCP/IP networking in Go
- The basics of the HTTP/2 protocol, including frames, headers, and streams

### Setting Up the Server

First, let's set up a basic server that listens for incoming connections. This is the starting point for our HTTP/2 server.

```go
package main

import (
    "log"
    "net"
)

func main() {
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    defer listener.Close()

    log.Println("Server listening on :8080")

    for {
        conn, err := listener.Accept()
        if err != nil {
            log.Printf("failed to accept connection: %v", err)
            continue
        }

        go handleConnection(conn)
    }
}

func handleConnection(conn net.Conn) {
    defer conn.Close()

    // Handle the HTTP/2 connection here
}
```

### Implementing HTTP/2 Connection

HTTP/2 uses binary framing over a single TCP connection. The initial handshake involves an HTTP/1.x-style upgrade or ALPN (Application-Layer Protocol Negotiation). For simplicity, we'll assume the client has already negotiated HTTP/2 with ALPN.

#### Reading Frames

HTTP/2 frames are structured as follows:

- **Length**: 2 bytes
- **Type**: 1 byte
- **Flags**: 1 byte
- **Stream ID**: 4 bytes
- **Payload**: Variable length (determined by the Length field)

```go
type FrameHeader struct {
    Length   uint16
    Type     byte
    Flags    byte
    StreamID uint32
}

func readFrame(conn net.Conn) (*FrameHeader, []byte, error) {
    var header [9]byte
    if _, err := io.ReadFull(conn, header[:]); err != nil {
        return nil, nil, err
    }

    frameHeader := &FrameHeader{
        Length:   binary.BigEndian.Uint16(header[0:2]),
        Type:     header[3],
        Flags:    header[4],
        StreamID: binary.BigEndian.Uint32(header[5:9]),
    }

    payload := make([]byte, frameHeader.Length)
    if _, err := io.ReadFull(conn, payload); err != nil {
        return nil, nil, err
    }

    return frameHeader, payload, nil
}
```

#### Handling Frames

We need to handle different types of frames. For simplicity, we'll only handle the `SETTINGS`, `HEADERS`, and `DATA` frames.

```go
func handleFrame(conn net.Conn, header *FrameHeader, payload []byte) error {
    switch header.Type {
    case SETTINGS:
        // Handle settings frame
        return handleSettings(header, payload)
    case HEADERS:
        // Handle headers frame
        return handleHeaders(header, payload)
    case DATA:
        // Handle data frame
        return handleData(header, payload)
    default:
        log.Printf("unhandled frame type: %d", header.Type)
        return nil
    }
}
```

#### Sending Frames

We also need to send frames back to the client.

```go
func sendDataFrame(conn net.Conn, streamID uint32, data []byte) error {
    header := FrameHeader{
        Length:   uint16(len(data)),
        Type:     DATA,
        Flags:    0,
        StreamID: streamID,
    }

    buf := make([]byte, 9+len(data))
    binary.BigEndian.PutUint16(buf[0:2], header.Length)
    buf[3] = header.Type
    buf[4] = header.Flags
    binary.BigEndian.PutUint32(buf[5:9], header.StreamID)

    copy(buf[9:], data)

    _, err := conn.Write(buf)
    return err
}
```

### Putting It All Together

Now, let's put everything together in the `handleConnection` function.

```go
func handleConnection(conn net.Conn) {
    for {
        header, payload, err := readFrame(conn)
        if err != nil {
            log.Printf("failed to read frame: %v", err)
            return
        }

        if err := handleFrame(conn, header, payload); err != nil {
            log.Printf("failed to handle frame: %v", err)
            return
        }
    }
}
```

### Flow Control

HTTP/2 includes flow control mechanisms. For simplicity, we won't implement a full flow control system here, but you should be aware that it involves managing window sizes for both the connection and each stream.

### Conclusion

This is a very basic implementation of an HTTP/2 server in Go. A complete HTTP/2 server would need to handle many more aspects of the protocol, including:

- Properly handling all frame types
- Implementing ALPN negotiation
- Managing flow control
- Handling errors gracefully
- Supporting PUSH promises
- Securing connections with TLS

This example should give you a starting point for understanding how HTTP/2 works and how you might implement it in Go. For production use, consider using the standard library's `http2` package or a third-party library that provides a complete implementation.